
<!--

project_euler_q2.md

SPDX-FileCopyrightNotice: 2023 Alexander Murphy <super7@alexmurphy.io>
SPDX-License-Identifier: CC-BY-4.0
SPDX-License-Identifier: CC-BY-NC-SA-4.0

The a solution to Q2 of the fabulous Project Euler.

-->

# Probably a reasonable solution to PE question 2

## Problem Statement

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:
>
> $1,2,3,5,8,13,21,34,55,89,...$
> 
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Analysis

This will be a nice exposition of Haskell's laziness, a Fibonacci sequence *generator* can be used. The odd numbers in the sequence can be filtered out, and the sum folded.

## Solution

```haskell
fib a
 | a == 1 = 1
 | a == 2 = 2
 | a > 2 = fib (a-1) + fib (a-2)

fib 32 -- 3524578
fib 33 -- 5702887, i'm lazy too...

sum . filter even $ map fib [1..32]
```

## Discussion

The solution above is *not* what was described in the analysis. A generator is not used as the $n$th Fibonnaci number is computed from scratch each time, rather than using the previously computed numbers.

An *actual* generator would look something like this:

```haskell
fibs a b = a : fibs b (a+b)
```

which could be taken from... 

```haskell
take 10 (fibs 0 1)
```

In fact, compared to the original:

```haskell
sum . filter even $ map fib [1..32] 
-- (15.04 secs, 3,664,801,152 bytes)
```

this solutions' efficiency is vastly superior:

```haskell
sum $ filter even $ takeWhile (< 4000000) (fibs 0 1) 
-- (0.01 secs, 86,568 bytes)
```

## Miscellanea

All copyrightable content is released under the Creative Commons By licence, v4.0, unless otherwise specified in the source code.

The problem statement is from [Project Euler](https://projecteuler.net/problem=1) used under licence (CC-BY-NC-SA-4.0).
